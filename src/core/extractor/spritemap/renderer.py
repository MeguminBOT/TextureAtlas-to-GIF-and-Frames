"""High-level Adobe Spritemap renderer for extracting symbol animations.

This module provides ``AdobeSpritemapRenderer``, which loads an Adobe Animate
export (Animation.json + spritemap JSON + atlas PNG) and renders each symbol
or timeline label into a sequence of cropped RGBA frames.
"""

from __future__ import annotations

import json
import math
from typing import Any, Dict, List, Optional, Tuple

from PIL import Image

from utils.utilities import Utilities
from .sprite_atlas import SpriteAtlas
from .symbols import Symbols
from .normalizer import normalize_animation_document
from .transform_matrix import TransformMatrix


class AdobeSpritemapRenderer:
    """Render symbol animations from Adobe Animate spritemap exports.

    Loads the animation metadata, spritemap JSON, and atlas image on
    construction, then exposes methods to list symbols, render frames,
    and populate default FPS settings.

    Attributes:
        animation_path: Filesystem path to Animation.json.
        spritemap_json_path: Filesystem path to the spritemap JSON.
        atlas_image_path: Filesystem path to the atlas bitmap.
        animation_json: Parsed Animation.json dict.
        frame_rate: Frames-per-second from metadata (default 24).
        filter_single_frame: Whether to skip single-frame animations.
        sprite_atlas: ``SpriteAtlas`` instance for sprite lookup.
        symbols: ``Symbols`` instance for timeline/symbol management.
    """

    def __init__(
        self,
        animation_path: str,
        spritemap_json_path: str,
        atlas_image_path: str,
        canvas_size=None,
        resample=Image.BICUBIC,
        filter_single_frame: bool = True,
    ):
        """Load animation metadata, spritemap JSON, and the atlas image.

        Args:
            animation_path: Path to Animation.json generated by Adobe Animate.
            spritemap_json_path: Path to the per-spritesheet JSON file.
            atlas_image_path: Path to the atlas bitmap.
            canvas_size: Optional ``(width, height)`` override for the render
                canvas; defaults to atlas dimensions.
            resample: Pillow resample filter for scaling operations.
            filter_single_frame: When ``True``, animations with only one frame
                are omitted from batch renders.
        """

        self.animation_path = animation_path
        self.spritemap_json_path = spritemap_json_path
        self.atlas_image_path = atlas_image_path

        with open(animation_path, "r", encoding="utf-8") as animation_file:
            self.animation_json = normalize_animation_document(
                json.load(animation_file)
            )

        with open(spritemap_json_path, "rb") as spritemap_file:
            spritemap_json = json.loads(spritemap_file.read().decode("utf-8-sig"))

        atlas_image = Image.open(atlas_image_path)
        if canvas_size is None:
            canvas_size = _infer_canvas_size(
                self.animation_json,
                spritemap_json,
                atlas_image.size,
            )

        self.frame_rate = self.animation_json.get("MD", {}).get("FRT", 24)
        self.filter_single_frame = filter_single_frame
        self.sprite_atlas = SpriteAtlas(
            spritemap_json, atlas_image, canvas_size, resample
        )
        self.symbols = Symbols(self.animation_json, self.sprite_atlas, canvas_size)

    def list_symbol_names(self) -> List[str]:
        """Return all symbol names defined in the animation document.

        Returns:
            List of symbol name strings.
        """

        return [
            symbol.get("SN")
            for symbol in self.animation_json.get("SD", {}).get("S", [])
            if symbol.get("SN")
        ]

    def build_animation_frames(
        self,
    ) -> Dict[str, List[Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]]]:
        """Render frames for every symbol and timeline label in the project.

        Symbols and labels that resolve to a single frame are skipped when
        ``filter_single_frame`` is enabled.

        Returns:
            Dict mapping folder/label names to lists of frame tuples. Each
            tuple contains ``(frame_name, image, bounds)`` where bounds is
            ``(x, y, width, height, offset_x, offset_y)``.
        """

        animations: Dict[
            str, List[Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]]
        ] = {}

        for symbol_name in self.list_symbol_names():
            frames = self._render_symbol_frames(symbol_name)
            if not frames:
                continue
            if self.filter_single_frame and len(frames) <= 1:
                continue
            folder_name = Utilities.strip_trailing_digits(symbol_name)
            animations.setdefault(folder_name, []).extend(frames)

        for label in self.symbols.get_label_ranges(None):
            frames = self._render_symbol_frames(
                None,
                start_frame=label["start"],
                end_frame=label["end"],
                frame_name_prefix=label["name"],
            )
            if not frames:
                continue
            if self.filter_single_frame and len(frames) <= 1:
                continue
            folder_name = label["name"]
            animations.setdefault(folder_name, []).extend(frames)

        return animations

    def _render_symbol_frames(
        self,
        symbol_name: Optional[str],
        start_frame: int = 0,
        end_frame: Optional[int] = None,
        frame_name_prefix: Optional[str] = None,
    ):
        """Render a contiguous range of frames for a symbol or timeline label.

        Frames are normalized to a common canvas size and cropped to their
        combined bounding box before being returned.

        Args:
            symbol_name: Name of the symbol, or ``None`` for the root timeline.
            start_frame: First frame index to render (inclusive).
            end_frame: Last frame index (exclusive); defaults to total length.
            frame_name_prefix: Prefix for generated frame names.

        Returns:
            List of ``(name, image, bounds)`` tuples, or empty if no valid
            frames exist.
        """

        total_frames = self.symbols.length(symbol_name)
        if total_frames == 0:
            return []

        if end_frame is None or end_frame > total_frames:
            end_frame = total_frames

        if start_frame >= end_frame:
            return []

        rendered_frames: List[
            Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]
        ] = []
        frames_with_index = []

        for frame_index in range(start_frame, end_frame):
            frame_image = self.symbols.render_symbol(symbol_name, frame_index)
            if frame_image is None:
                continue
            frames_with_index.append((frame_index - start_frame, frame_image))

        if not frames_with_index:
            return []

        sizes = [frame.size for _, frame in frames_with_index]
        max_width = max(width for width, _ in sizes)
        max_height = max(height for _, height in sizes)
        canvas_size = (max_width, max_height)

        normalized_frames = []
        for frame_index, frame in frames_with_index:
            if frame.size != canvas_size:
                new_frame = Image.new("RGBA", canvas_size)
                offset = (
                    (canvas_size[0] - frame.size[0]) // 2,
                    (canvas_size[1] - frame.size[1]) // 2,
                )
                new_frame.paste(frame, offset)
                frame = new_frame
            normalized_frames.append((frame_index, frame))

        min_x, min_y, max_x, max_y = float("inf"), float("inf"), 0, 0
        for _, frame in normalized_frames:
            bbox = frame.getbbox()
            if bbox:
                min_x = min(min_x, bbox[0])
                min_y = min(min_y, bbox[1])
                max_x = max(max_x, bbox[2])
                max_y = max(max_y, bbox[3])

        if min_x > max_x:
            return []

        prefix = frame_name_prefix or (symbol_name if symbol_name else "timeline")

        for frame_index, frame in normalized_frames:
            cropped_frame = frame.crop((min_x, min_y, max_x, max_y))
            frame_name = f"{prefix}_{frame_index:04d}"
            rendered_frames.append(
                (
                    frame_name,
                    cropped_frame,
                    (0, 0, cropped_frame.width, cropped_frame.height, 0, 0),
                )
            )

        return rendered_frames

    def ensure_animation_defaults(self, settings_manager, spritesheet_name):
        """Populate animation FPS defaults in the settings manager if missing.

        Iterates over all symbols and timeline labels and ensures each has an
        entry in ``settings_manager.animation_settings`` with at least an
        ``fps`` key.

        Args:
            settings_manager: A settings manager exposing ``animation_settings``.
            spritesheet_name: Base name used to construct full setting keys.
        """

        for animation_name in self.list_symbol_names():
            folder_name = Utilities.strip_trailing_digits(animation_name)
            full_name = f"{spritesheet_name}/{folder_name}"
            sprite_settings = settings_manager.animation_settings.setdefault(
                full_name, {}
            )
            sprite_settings.setdefault("fps", self.frame_rate)

        for label in self.symbols.get_label_ranges(None):
            label_name = label["name"]
            full_name = f"{spritesheet_name}/{label_name}"
            sprite_settings = settings_manager.animation_settings.setdefault(
                full_name, {}
            )
            sprite_settings.setdefault("fps", self.frame_rate)

    def render_animation(self, target):
        """Render frames for a symbol or timeline label.

        Args:
            target: Either a symbol name string, or a dict with ``type`` and
                ``value`` keys (type may be ``"symbol"`` or ``"timeline_label"``).

        Returns:
            List of ``(name, image, bounds)`` tuples for the requested target.
        """

        target_type, target_value = self._normalize_target(target)

        if target_type == "timeline_label":
            label_range = self.symbols.get_label_range(None, target_value)
            if not label_range:
                return []
            return self._render_symbol_frames(
                None,
                start_frame=label_range["start"],
                end_frame=label_range["end"],
                frame_name_prefix=target_value,
            )

        return self._render_symbol_frames(target_value)

    def _normalize_target(self, target):
        """Normalize a render target to a ``(type, value)`` pair.

        Args:
            target: A string (treated as symbol name) or dict with ``type``
                and ``value`` keys.

        Returns:
            Tuple of ``(target_type, target_value)``.
        """

        if isinstance(target, dict):
            return target.get("type", "symbol"), target.get("value")
        return "symbol", target


def _infer_canvas_size(animation_json, spritemap_json, atlas_size):
    """Compute a canvas size large enough to contain all transformed sprites.

    Scans every symbol timeline and atlas sprite instance, applying their
    transforms to determine the maximum extent any sprite can reach. The
    returned dimensions ensure no sprite is clipped during rendering.

    Args:
        animation_json: Normalized Animation.json dict.
        spritemap_json: Parsed spritemap JSON with sprite regions.
        atlas_size: Default ``(width, height)`` from the atlas image.

    Returns:
        A ``(width, height)`` tuple at least as large as ``atlas_size`` and
        sufficient to hold all transformed sprite bounds.
    """

    sprite_sizes = _collect_sprite_sizes(spritemap_json)
    if not sprite_sizes:
        return atlas_size

    timelines = _collect_timelines(animation_json)
    if not timelines:
        return atlas_size

    bounds_cache: Dict[Optional[str], Optional[Tuple[float, float, float, float]]] = {}
    visiting: set[Optional[str]] = set()

    def symbol_bounds(
        symbol_name: Optional[str],
    ) -> Optional[Tuple[float, float, float, float]]:
        """Return the cumulative bounding box for all frames of a symbol.

        Recursively resolves nested symbol instances and caches results to
        avoid redundant traversals. Cyclic references are detected via the
        ``visiting`` set and return ``None`` to break infinite loops.

        Args:
            symbol_name: Name of the symbol, or ``None`` for the root timeline.

        Returns:
            A ``(min_x, min_y, max_x, max_y)`` tuple, or ``None`` if the
            symbol has no renderable content.
        """

        if symbol_name in bounds_cache:
            return bounds_cache[symbol_name]
        if symbol_name in visiting:
            return None
        visiting.add(symbol_name)

        min_x = float("inf")
        min_y = float("inf")
        max_x = float("-inf")
        max_y = float("-inf")

        for layer in timelines.get(symbol_name, []):
            for frame in layer.get("FR", []):
                for element in frame.get("E", []):
                    bounds = _element_bounds(element, sprite_sizes, symbol_bounds)
                    if not bounds:
                        continue
                    min_x = min(min_x, bounds[0])
                    min_y = min(min_y, bounds[1])
                    max_x = max(max_x, bounds[2])
                    max_y = max(max_y, bounds[3])

        visiting.remove(symbol_name)

        if min_x == float("inf"):
            bounds_cache[symbol_name] = None
        else:
            bounds_cache[symbol_name] = (min_x, min_y, max_x, max_y)
        return bounds_cache[symbol_name]

    for symbol_name in timelines.keys():
        symbol_bounds(symbol_name)

    max_abs_x = 0.0
    max_abs_y = 0.0
    for bounds in bounds_cache.values():
        if not bounds:
            continue
        min_x, min_y, max_x, max_y = bounds
        max_abs_x = max(max_abs_x, abs(min_x), abs(max_x))
        max_abs_y = max(max_abs_y, abs(min_y), abs(max_y))

    if max_abs_x == 0 and max_abs_y == 0:
        return atlas_size

    padding = 32.0
    inferred_width = int(math.ceil(max_abs_x * 2.0 + padding))
    inferred_height = int(math.ceil(max_abs_y * 2.0 + padding))
    return (
        max(atlas_size[0], inferred_width),
        max(atlas_size[1], inferred_height),
    )


def _collect_sprite_sizes(spritemap_json: Dict[str, Any]) -> Dict[str, Tuple[int, int]]:
    """Build a mapping of sprite names to their pixel dimensions.

    Args:
        spritemap_json: Parsed spritemap JSON containing an ``ATLAS.SPRITES``
            list.

    Returns:
        Dict mapping each sprite name to its ``(width, height)`` in pixels.
    """

    sizes: Dict[str, Tuple[int, int]] = {}
    for sprite in spritemap_json.get("ATLAS", {}).get("SPRITES", []):
        data = sprite.get("SPRITE", sprite)
        name = data.get("name")
        if not name:
            continue
        sizes[name] = (int(data.get("w", 0)), int(data.get("h", 0)))
    return sizes


def _collect_timelines(animation_json: Dict[str, Any]):
    """Extract all symbol timelines from a normalized animation document.

    Args:
        animation_json: Normalized Animation.json dict with ``SD`` (symbol
            dictionary) and ``AN`` (root animation) sections.

    Returns:
        Dict mapping symbol names (or ``None`` for the root timeline) to
        their layer lists.
    """

    timelines: Dict[Optional[str], List[Dict[str, Any]]] = {}
    for symbol in animation_json.get("SD", {}).get("S", []):
        name = symbol.get("SN")
        if not name:
            continue
        layers = symbol.get("TL", {}).get("L", [])
        timelines[name] = layers
    timelines[None] = animation_json.get("AN", {}).get("TL", {}).get("L", [])
    return timelines


def _element_bounds(element, sprite_sizes, symbol_bounds_fn):
    """Compute the transformed bounding box for a single frame element.

    Handles both atlas sprite instances (``ASI``) and nested symbol instances
    (``SI``), recursively resolving child symbol bounds when necessary.

    Args:
        element: A frame element dict potentially containing ``ASI`` or ``SI``.
        sprite_sizes: Dict mapping sprite names to ``(width, height)``.
        symbol_bounds_fn: Callable accepting a symbol name and returning its
            cumulative bounds, used for recursive symbol resolution.

    Returns:
        A ``(min_x, min_y, max_x, max_y)`` tuple, or ``None`` if the element
        cannot be resolved.
    """

    if not isinstance(element, dict):
        return None
    if "ASI" in element:
        atlas = element["ASI"]
        sprite_name = atlas.get("N")
        if not sprite_name:
            return None
        sprite_size = sprite_sizes.get(sprite_name)
        if not sprite_size:
            return None
        matrix = TransformMatrix.parse(atlas.get("M3D"))
        return _transform_sprite(sprite_size, matrix)
    if "SI" in element:
        instance = element["SI"]
        child_name = instance.get("SN")
        if not child_name:
            return None
        child_bounds = symbol_bounds_fn(child_name)
        if not child_bounds:
            return None
        matrix = TransformMatrix.parse(instance.get("M3D"))
        return _transform_bounds(child_bounds, matrix)
    return None


def _transform_sprite(sprite_size: Tuple[int, int], matrix: TransformMatrix):
    """Apply a transform to an origin-anchored sprite and return its bounds.

    Args:
        sprite_size: ``(width, height)`` of the sprite in pixels.
        matrix: Affine transform to apply.

    Returns:
        Transformed ``(min_x, min_y, max_x, max_y)`` bounding box.
    """

    width, height = sprite_size
    return _transform_bounds((0.0, 0.0, float(width), float(height)), matrix)


def _transform_bounds(
    bounds: Tuple[float, float, float, float], matrix: TransformMatrix
) -> Tuple[float, float, float, float]:
    """Transform a bounding box and return its axis-aligned enclosure.

    Applies the affine transform to each corner of the input rectangle and
    computes the smallest axis-aligned rectangle containing the results.

    Args:
        bounds: ``(min_x, min_y, max_x, max_y)`` rectangle.
        matrix: Affine transform to apply.

    Returns:
        Transformed ``(min_x, min_y, max_x, max_y)`` bounding box.
    """

    min_x, min_y, max_x, max_y = bounds
    corners = (
        (min_x, min_y),
        (min_x, max_y),
        (max_x, min_y),
        (max_x, max_y),
    )
    a, b, c, d, e, f = matrix.m.reshape(-1)[:6]
    transformed = ((a * x + b * y + c, d * x + e * y + f) for (x, y) in corners)
    xs, ys = zip(*transformed)
    return (min(xs), min(ys), max(xs), max(ys))
